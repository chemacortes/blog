<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Chema Cortés">
  <meta name="description" content="Estudio función factorial en scala | Como continuación al artículo que dediqué al estudio del factorial, voy a explicar cómo se haría este famoso...">

  <link rel="stylesheet" type="text/css" href="../../../../theme/css/styles.425931e9.min.css">

  <script src="../../../../theme/js/scripts.7db5858b.min.js" type="text/javascript"></script>

  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">

  <link href="https://chemacortes.github.io/blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Hyperreals *R Full Atom Feed" />

<meta name="keywords" content="functional programming, lambda calculus, math, programación, programming, algorithm, factorial">

  <title>Estudio función factorial en scala | Hyperreals *R</title>

</head>

<body>
  <aside>
    <div id="user_meta">
      <a href="../../../..">
        <img src="https://s.gravatar.com/avatar/b20d114964d6d77c209aadbe9a152e87?s=80" id="logo">
      </a>
      <h2><a href="../../../.." class="nohover">Hyperreals *R</a></h2>
      <p>Quarks, bits y otras criaturas infinitesimales</p>
      <div class="social">
          <a href="https://twitter.com/chemacortes" title="twitter" target="_blank" rel="noopener noreferrer"><i class="fa fa-twitter fa-lg"></i></a>
          <a href="https://github.com/chemacortes" title="github" target="_blank" rel="noopener noreferrer"><i class="fa fa-github fa-lg"></i></a>
          <a href="https://bitbucket.org/chemacortes/" title="bitbucket" target="_blank" rel="noopener noreferrer"><i class="fa fa-bitbucket fa-lg"></i></a>
          <a href="https://stackoverflow.com/users/1243400/chemacortes" title="stackoverflow" target="_blank" rel="noopener noreferrer"><i class="fa fa-stack-overflow fa-lg"></i></a>
          <a href="https://linkedin.com/in/chemacortes" title="linkedin" target="_blank" rel="noopener noreferrer"><i class="fa fa-linkedin fa-lg"></i></a>
      </div>
      <ul>
        <li><a href="feeds/all.atom.xml" target="_blank" rel="noopener noreferrer">All Feeds<i class="fa fa-external-link-square fa-lg"></i></a></li>
        <li><a href="feeds/scala.atom.xml" target="_blank" rel="noopener noreferrer">Scala Feeds<i class="fa fa-external-link-square fa-lg"></i></a></li>
        <li><a href="feeds/python.atom.xml" target="_blank" rel="noopener noreferrer">Python Feeds<i class="fa fa-external-link-square fa-lg"></i></a></li>
        <li><a href="feeds/notas.atom.xml" target="_blank" rel="noopener noreferrer">Notas Feeds<i class="fa fa-external-link-square fa-lg"></i></a></li>
        <li><a href="https://mathstodon.xyz/@chemacortes" target="_blank" rel="noopener noreferrer">Mastodon<i class="fa fa-external-link-square fa-lg"></i></a></li>
      </ul>
    </div>
  </aside>

  <main id="main">
    <header>
      <p id="header">
      <a href="../../../..">Home</a>

      &#124; <a href="../../../../pages/aboutme/">Quién&nbsp;soy</a>
      &#124; <a href="../../../../pages/busqueda-python-es/">Búsqueda&nbsp;python-es</a>
      &#124; <a href="https://chemacortes.github.io/blog/feeds/all.atom.xml">Atom Feed</a>
      </p>
<p>
<a href="../../../../index.html">Posts</a>
&#124; <a href="../../../../tag/">Tags</a>
&#124; <a href="../../../../category/">Categories</a>
&#124; <a href="../../../../archives.html">Archive</a>
</p>    </header>

<article>
<div class="article_meta">
  <p>Posted <time data-reltime datetime="2011-10-17T20:49:00+02:00">lun 17 octubre 2011</time>
   by Chema Cortés  </p>
  <p>
  Category: <a href="../../../../category/scala/">Scala</a>
&ndash;&ndash;  Tags:
    <a href="../../../../tag/algorithm/">algorithm</a>,    <a href="../../../../tag/factorial/">factorial</a>  </p>
</div>  <div class="article_title">
    <h1><a href="../../../../2011/10/17/estudio-funcion-factorial-en-scala/" class="nohover">Estudio función factorial en&nbsp;scala</a></h1>
  </div>
  <div class="article_text">
    <p>Como continuación al artículo que dediqué al <a href="../../../../2011/06/06/estudio-funcion-factorial/">estudio del factorial</a>, voy a explicar cómo se haría este famoso algoritmo usando <a href="http://scala-lang.org" title="Scala programming language">scala</a>. Tengo que añadir que tan sólo llevo una semana con el lenguaje scala, por lo que es muy probable que haya algún aspecto de este lenguaje que me haya dejado por el&nbsp;camino.</p>
<h2>Versión recursiva (y <em>one-line</em>)</h2>
<p>La forma básica de la función&nbsp;sería:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fact</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="nc">Int</span><span class="p">):</span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="n">n</span><span class="o">*</span><span class="n">fact</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>

<p>Si se compara con la función recursiva en python, no parece que haya mucha diferencia, con excepción de que en scala existe el tipado de&nbsp;datos.</p>
<p>Esta función es en realidad una sóla línea, por lo que podíamos haberla escrito de esta&nbsp;manera:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fact</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="nc">Int</span><span class="p">):</span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">n</span><span class="o">*</span><span class="n">fact</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>

<p>Es una clara señal de la orientación funcional que tiene&nbsp;scala.</p>
<p>Al igual que python, esta función recursiva se corta cuando se sobrepasa un cierto límite de llamadas recursivas para proteger la memoria del&nbsp;sistema.</p>
<p>El compilador de Scala posee una optimización especial denominda de <em>&#8220;LLamada Terminal&#8221;</em> (<a href="http://en.wikipedia.org/wiki/Tail_call" title="Tail Call">Tail Call</a>)<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup> (optimización que no existe en <span class="caps">JVM</span>). Este tipo de optimizaciones son posibles cuando la última línea a ejecutar de la función es únicamente la llamada recursiva a sí misma, con lo cuál hace innecesario guardar el stack de ejecución puesto que no quedarían más líneas para&nbsp;ejecutar.</p>
<p>Para que sea posible aplicar esta optimización de &#8220;llamada terminal&#8221;, tenemos que reescribir nuestra función de modo que la última línea sea una llamada a sí misma. Para ello usaremos una función acumuladora que se encargue de realizar la multiplicación previamente a la llamada. Casi mejor si vemos el&nbsp;código:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fact</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="nc">Int</span><span class="p">):</span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">factAcc</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">acc</span><span class="p">:</span><span class="nc">BigInt</span><span class="p">):</span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">factAcc</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="o">*</span><span class="n">acc</span><span class="p">)</span>

<span class="w">    </span><span class="n">factAcc</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>En las últimas versiones de scala existe una <em>&#8220;anotación&#8221;</em> especial para indicar al compilador de scala que intente aplicar la optimización de &#8220;LLamada Terminal&#8221;, o que nos dé un aviso de no poder hacerlo. Finalmente, así quedaría el código de nuestra función&nbsp;recursiva:</p>
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nn">scala</span><span class="p">.</span><span class="nn">annotation</span><span class="p">.</span><span class="n">tailrec</span>

<span class="k">def</span><span class="w"> </span><span class="nf">fact</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="nc">Int</span><span class="p">):</span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@tailrec</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">factAcc</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">acc</span><span class="p">:</span><span class="nc">BigInt</span><span class="p">):</span><span class="nc">BigInt</span><span class="o">=</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">factAcc</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="o">*</span><span class="n">acc</span><span class="p">)</span>

<span class="w">    </span><span class="n">factAcc</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<h2>Versión&nbsp;iterativa</h2>
<p>Es la versión más&nbsp;sencilla:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fact</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="nc">Int</span><span class="p">):</span><span class="nc">BigInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="n">res</span><span class="o">=</span><span class="nc">BigInt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">        </span><span class="n">res</span><span class="o">*=</span><span class="n">i</span>
<span class="w">    </span><span class="n">res</span>
<span class="p">}</span>
</code></pre></div>

<h2>Fórmula de&nbsp;Stirling</h2>
<p>Para completar el estudio, podemos ver cómo sería la función de Stiling en Scala, bastante similar, como puede verse, a su versión en&nbsp;python:</p>
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nn">math</span><span class="p">.</span><span class="n">_</span>

<span class="k">def</span><span class="w"> </span><span class="nf">fact</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="nc">Int</span><span class="p">):</span><span class="nc">Double</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nc">Pi</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">pow</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="nc">E</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
</code></pre></div>

<div class="footnote">
<hr>
<ol>
<li id="fn:1">
<p>Existe algún intento para implementar esta optimización de &#8220;Tail Call&#8221; en python, con algunos decoradores más o menos funcionales. Si quieres ver motivos en contra, visita el artículo que escribió Guido sobre el tema: <a href="http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html">http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html</a>&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
  </div>

  <div id="article_comments">
    <div id="disqus_thread">
    </div>
  </div>

  <script id="dsq-count-scr" src="https://hyperreals.disqus.com/count.js" async></script>
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.identifier = "2011/10/17/estudio-funcion-factorial-en-scala/";
        this.page.title = "Estudio función factorial en&nbsp;scala";
    };
    loadDisqus = function(sitename) {
      var d = document, s = d.createElement('script');
      s.src = 'https://hyperreals.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    };
    loadDisqus();
  </script>
</article>


    <div id="ending_message">
        <p>&copy; Chema Cortés. Built using <a href="http://getpelican.com">Pelican</a>. Theme is <a href="https://github.com/pR0Ps/pelican-subtle">subtle</a> by <a href="http://cmetcalfe.ca">Carey Metcalfe</a>. Based on <a href="https://github.com/giulivo/pelican-svbhack">svbhack</a> by Giulio Fidente.</p>
    </div>
  </main>

  <script type="text/javascript">
    window.addEventListener('load', skipHeader)
  </script>


</body>
</html>