<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Chema Cortés">
  <meta name="description" content="Estudio función factorial en scala | Como continuación al artículo que dediqué al estudio del factorial, voy a explicar cómo se haría este famoso...">

  <link rel="stylesheet" type="text/css" href="https://blog.ch3m4.org/theme/css/style.7098921b.min.css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

  <link href="https://blog.ch3m4.org/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Hyperreals *R Full Atom Feed" />

<meta name="keywords" content="functional programming, programming, programación, lambda calculus, math, algorithm, factorial">

  <script src="https://blog.ch3m4.org/theme/js/lw-timeago.25926835.min.js" type="text/javascript"></script>

  <title>
Estudio función factorial en scala | Hyperreals *R  </title>

</head>

<body>
  <aside>
    <div id="user_meta">
      <a href="https://blog.ch3m4.org">
        <img src="https://s.gravatar.com/avatar/b20d114964d6d77c209aadbe9a152e87?s=80" alt="logo" id="logo">
      </a>
      <h2><a href="https://blog.ch3m4.org" class="nohover">Hyperreals *R</a></h2>
      <p>Quarks, bits y otras criaturas infinitesimales</p>
      <div class="social">
          <a href="https://twitter.com/chemacortes" title="twitter"><i class="fa fa-twitter fa-lg"></i></a>
          <a href="https://github.com/chemacortes" title="github"><i class="fa fa-github fa-lg"></i></a>
          <a href="https://bitbucket.org/chemacortes/" title="bitbucket"><i class="fa fa-bitbucket fa-lg"></i></a>
          <a href="http://stackoverflow.com/users/1243400/chemacortes" title="stackoverflow"><i class="fa fa-stack-overflow fa-lg"></i></a>
          <a href="https://linkedin.com/in/chemacortes" title="linkedin"><i class="fa fa-linkedin fa-lg"></i></a>
      </div>
      <ul>
        <li><a href="/feeds/all.atom.xml">All Feeds<i class="fa fa-external-link-square fa-lg"></i></a></li>
        <li><a href="/feeds/scala.atom.xml">Scala Feeds<i class="fa fa-external-link-square fa-lg"></i></a></li>
        <li><a href="/feeds/python.atom.xml">Python Feeds<i class="fa fa-external-link-square fa-lg"></i></a></li>
        <li><a href="https://www.coursera.org/user/9408450118c4cfeddff015451ed358b6">my coursera<i class="fa fa-external-link-square fa-lg"></i></a></li>
      </ul>
    </div>
  </aside>

  <main id="main">
    <header>
      <p id="header">
      <a href="https://blog.ch3m4.org">Home</a>
      
      &#124; <a href="https://blog.ch3m4.org/pages/aboutme/">Quién&nbsp;soy</a>
      &#124; <a href="https://blog.ch3m4.org/pages/busqueda-python-es/">Búsqueda&nbsp;python-es</a>
      &#124; <a href="https://blog.ch3m4.org/feeds/all.atom.xml">Atom Feed</a>
      </p>
<p>
<a href="https://blog.ch3m4.org/index.html">Posts</a>
&#124; <a href="https://blog.ch3m4.org/tag/">Tags</a>
&#124; <a href="https://blog.ch3m4.org/category/">Categories</a>
&#124; <a href="https://blog.ch3m4.org/archives.html">Archive</a>
</p>    </header>

<article>
  <div class="article_title">
    <h1><a href="https://blog.ch3m4.org/2011/10/17/estudio-funcion-factorial-en-scala/" class="nohover">Estudio función factorial en&nbsp;scala</a></h1>
  </div>
  <div class="article_meta">
    <p>Posted <time data-timeago datetime="2011-10-17T20:49:00+02:00">lun 17 octubre 2011</time>
     by Chema Cortés    </p>
    <p>
    Category: <a href="https://blog.ch3m4.org/category/scala/">Scala</a>
&ndash;&ndash;    Tags:
      <a href="https://blog.ch3m4.org/tag/algorithm/">algorithm</a>,      <a href="https://blog.ch3m4.org/tag/factorial/">factorial</a>    </p>
  </div>
  <div class="article_text">
    <p>Como continuación al artículo que dediqué al <a href="https://blog.ch3m4.org/2011/06/06/estudio-funcion-factorial/">estudio del factorial</a>, voy a explicar cómo se haría este famoso algoritmo usando <a href="http://scala-lang.org" title="Scala programming language">scala</a>. Tengo que añadir que tan sólo llevo una semana con el lenguaje scala, por lo que es muy probable que haya algún aspecto de este lenguaje que me haya dejado por el&nbsp;camino.</p>
<h2>Versión recursiva (y <em>one-line</em>)</h2>
<p>La forma básica de la función&nbsp;sería:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">fact</span><span class="o">(</span><span class="n">n</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span><span class="k">:</span><span class="kt">BigInt</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="mi">1</span>
    <span class="k">else</span> <span class="n">n</span><span class="o">*</span><span class="n">fact</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</pre></div>
</td></tr></table>

<p>Si se compara con la función recursiva en python, no parece que haya mucha diferencia, con excepción de que en scala existe el tipado de&nbsp;datos.</p>
<p>Esta función es en realidad una sóla línea, por lo que podíamos haberla escrito de esta&nbsp;manera:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">fact</span><span class="o">(</span><span class="n">n</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span><span class="k">:</span><span class="kt">BigInt</span> <span class="o">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span><span class="o">*</span><span class="n">fact</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</pre></div>
</td></tr></table>

<p>Es una clara señal de la orientación funcional que tiene&nbsp;scala.</p>
<p>Al igual que python, esta función recursiva se corta cuando se sobrepasa un cierto límite de llamadas recursivas para proteger la memoria del&nbsp;sistema.</p>
<p>El compilador de Scala posee una optimización especial denominda de <em>&#8220;LLamada Terminal&#8221;</em> (<a href="http://en.wikipedia.org/wiki/Tail_call" title="Tail Call">Tail Call</a>)<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup> (optimización que no existe en <span class="caps">JVM</span>). Este tipo de optimizaciones son posibles cuando la última línea a ejecutar de la función es únicamente la llamada recursiva a sí misma, con lo cuál hace innecesario guardar el stack de ejecución puesto que no quedarían más líneas para&nbsp;ejecutar.</p>
<p>Para que sea posible aplicar esta optimización de &#8220;llamada terminal&#8221;, tenemos que reescribir nuestra función de modo que la última línea sea una llamada a sí misma. Para ello usaremos una función acumuladora que se encargue de realizar la multiplicación previamente a la llamada. Casi mejor si vemos el&nbsp;código:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">fact</span><span class="o">(</span><span class="n">n</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span><span class="k">:</span><span class="kt">BigInt</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">factAcc</span><span class="o">(</span><span class="n">n</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span> <span class="n">acc</span><span class="k">:</span><span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span><span class="kt">BigInt</span> <span class="o">=</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">&lt;=</span><span class="mi">1</span><span class="o">)</span> <span class="n">acc</span> <span class="k">else</span> <span class="n">factAcc</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">*</span><span class="n">acc</span><span class="o">)</span>

    <span class="n">factAcc</span><span class="o">(</span><span class="n">n</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>

<p>En las últimas versiones de scala existe una <em>&#8220;anotación&#8221;</em> especial para indicar al compilador de scala que intente aplicar la optimización de &#8220;LLamada Terminal&#8221;, o que nos dé un aviso de no poder hacerlo. Finalmente, así quedaría el código de nuestra función&nbsp;recursiva:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.annotation.tailrec</span>

<span class="k">def</span> <span class="n">fact</span><span class="o">(</span><span class="n">n</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span><span class="k">:</span><span class="kt">BigInt</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nd">@tailrec</span>
    <span class="k">def</span> <span class="n">factAcc</span><span class="o">(</span><span class="n">n</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span> <span class="n">acc</span><span class="k">:</span><span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span><span class="kt">BigInt</span><span class="o">=</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">&lt;=</span><span class="mi">1</span><span class="o">)</span> <span class="n">acc</span> <span class="k">else</span> <span class="n">factAcc</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">*</span><span class="n">acc</span><span class="o">)</span>

    <span class="n">factAcc</span><span class="o">(</span><span class="n">n</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>

<h2>Versión&nbsp;iterativa</h2>
<p>Es la versión más&nbsp;sencilla:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">fact</span><span class="o">(</span><span class="n">n</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span><span class="k">:</span><span class="kt">BigInt</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">res</span><span class="k">=</span><span class="nc">BigInt</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span><span class="o">)</span>
        <span class="n">res</span><span class="o">*=</span><span class="n">i</span>
    <span class="n">res</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>

<h2>Fórmula de&nbsp;Stirling</h2>
<p>Para completar el estudio, podemos ver cómo sería la función de Stiling en Scala, bastante similar, como puede verse, a su versión en&nbsp;python:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">math._</span>

<span class="k">def</span> <span class="n">fact</span><span class="o">(</span><span class="n">n</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span><span class="k">:</span><span class="kt">Double</span> <span class="o">=</span>
    <span class="n">sqrt</span><span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="nc">Pi</span><span class="o">*</span><span class="n">n</span><span class="o">)*</span><span class="n">pow</span><span class="o">(</span><span class="n">n</span><span class="o">/</span><span class="n">E</span><span class="o">,</span><span class="n">n</span><span class="o">)</span>
</pre></div>
</td></tr></table>

<div class="footnote">
<hr>
<ol>
<li id="fn:1">
<p>Existe algún intento para implementar esta optimización de &#8220;Tail Call&#8221; en python, con algunos decoradores más o menos funcionales. Si quieres ver motivos en contra, visita el artículo que escribió Guido sobre el tema: <a href="http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html">http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html</a>&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
  </div>
  <hr>
  
  <ul class="pager">
          <li class="previous">
               <a href="https://blog.ch3m4.org/2011/10/08/rentree-nueva-temporada/" title="Anterior">
                    <i class="fa fa-arrow-circle-left"></i>
                   Rentrée (nueva&nbsp;temporada)
               </a>
           </li>
           <li class="next">
              <a href="https://blog.ch3m4.org/2011/12/01/web2py-con-pilas-incluidas/" title="Siguiente">
                   web2py, con pilas&nbsp;incluidas
                   <i class="fa fa-arrow-circle-right"></i>
               </a>
           </li>
   </ul>
   With category <a href="https://blog.ch3m4.org/category/scala/">Scala</a>:
   <ul class="pager">
        <li class="next">
             <a href="https://blog.ch3m4.org/2012/02/07/estudio-funcion-factorial-en-scala-revision-funcional/" title="Siguiente en misma categoría">
                 Estudio función factorial en scala - Revisión&nbsp;funcional
                 <i class="fa fa-arrow-circle-o-right"></i>
             </a>
        </li>

   </ul>

    
  <div id="article_comments">
    <div id="disqus_thread">
    </div>
  </div>

  <script type="text/javascript">
    var disqus_identifier = "2011/10/17/estudio-funcion-factorial-en-scala/";
    loadDisqus = function() {
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//hyperreals.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    };
    loadDisqus();
  </script>
</article>


    <div id="ending_message">
        <p>&copy; Chema Cortés. Built using <a href="http://getpelican.com">Pelican</a>. Theme is <a href="https://github.com/pR0Ps/pelican-subtle">subtle</a> by <a href="http://cmetcalfe.ca">Carey Metcalfe</a>. Based on <a href="https://github.com/giulivo/pelican-svbhack">svbhack</a> by Giulio Fidente.</p>
    </div>
  </main>

  <script type="text/javascript">
    window.addEventListener('load', function(){
    if (window.location.pathname != '/' && window.location.pathname != '/index.html'){
      window.scroll(0, document.getElementById('main').offsetTop);
    }})
  </script>


<script type="text/javascript">window.addEventListener("load", lw_timeago);</script>
</body>
</html>