<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Chema Cortés">
  <meta name="description" content="Descriptores - Parte 3 | Hasta ahora hemos visto cómo funcionan los descriptores para acceder a atributos de datos que funcionan como “propiedades”...">

  <link rel="stylesheet" type="text/css" href="https://blog.ch3m4.org/theme/css/style.82b4bc13.min.css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

  <link href="https://blog.ch3m4.org/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Hyperreals *R Full Atom Feed" />

<meta name="keywords" content="functional programming, programming, programación, lambda calculus, math, descriptor, técnicas dinámicas">

  <script src="https://blog.ch3m4.org/theme/js/lw-timeago.25926835.min.js" type="text/javascript"></script>

  <title>
Descriptores - Parte 3 | Hyperreals *R  </title>

</head>

<body>
  <aside>
    <div id="user_meta">
      <a href="https://blog.ch3m4.org">
        <img src="https://s.gravatar.com/avatar/b20d114964d6d77c209aadbe9a152e87?s=80" alt="logo" id="logo">
      </a>
      <h2><a href="https://blog.ch3m4.org" class="nohover">Hyperreals *R</a></h2>
      <p>Quarks, bits y otras criaturas infinitesimales</p>
      <div class="social">
          <a href="https://twitter.com/chemacortes" title="twitter"><i class="fa fa-twitter fa-lg"></i></a>
          <a href="https://github.com/chemacortes" title="github"><i class="fa fa-github fa-lg"></i></a>
          <a href="https://bitbucket.org/chemacortes/" title="bitbucket"><i class="fa fa-bitbucket fa-lg"></i></a>
          <a href="http://stackoverflow.com/users/1243400/chemacortes" title="stackoverflow"><i class="fa fa-stack-overflow fa-lg"></i></a>
          <a href="https://plus.google.com/+ChemaCortés" title="google+"><i class="fa fa-google-plus fa-lg"></i></a>
          <a href="https://linkedin.com/in/chemacortes" title="linkedin"><i class="fa fa-linkedin fa-lg"></i></a>
      </div>
      <ul>
        <li><a href="/feeds/all.atom.xml">All Feeds<i class="fa fa-external-link-square fa-lg"></i></a></li>
        <li><a href="/feeds/scala.atom.xml">Scala Feeds<i class="fa fa-external-link-square fa-lg"></i></a></li>
        <li><a href="/feeds/python.atom.xml">Python Feeds<i class="fa fa-external-link-square fa-lg"></i></a></li>
        <li><a href="https://www.coursera.org/user/9408450118c4cfeddff015451ed358b6">my coursera<i class="fa fa-external-link-square fa-lg"></i></a></li>
      </ul>
    </div>
  </aside>

  <main id="main">
    <header>
      <p id="header">
      <a href="https://blog.ch3m4.org">Home</a>
      
      &#124; <a href="https://blog.ch3m4.org/pages/aboutme/">Quién&nbsp;soy</a>
      &#124; <a href="https://blog.ch3m4.org/pages/busqueda-python-es/">Búsqueda&nbsp;python-es</a>
      &#124; <a href="https://blog.ch3m4.org/feeds/all.atom.xml">Atom Feed</a>
      </p>
<p>
<a href="https://blog.ch3m4.org/index.html">Posts</a>
&#124; <a href="https://blog.ch3m4.org/tag/">Tags</a>
&#124; <a href="https://blog.ch3m4.org/category/">Categories</a>
&#124; <a href="https://blog.ch3m4.org/archives.html">Archive</a>
</p>    </header>

<article>
  <div class="article_title">
    <h1><a href="https://blog.ch3m4.org/2012/06/05/descriptores-parte-3/" class="nohover">Descriptores - Parte&nbsp;3</a></h1>
  </div>
  <div class="article_meta">
    <p>Posted <time data-timeago datetime="2012-06-05T00:37:00+02:00">mar 05 junio 2012</time>
     by Chema Cortés    </p>
    <p>
    Category: <a href="https://blog.ch3m4.org/category/python/">Python</a>
&ndash;&ndash;    Tags:
      <a href="https://blog.ch3m4.org/tag/descriptor/">descriptor</a>,      <a href="https://blog.ch3m4.org/tag/tecnicas-dinamicas/">técnicas dinámicas</a>    </p>
  </div>
  <div class="article_text">
    <p>Hasta ahora hemos visto cómo funcionan los <em>descriptores</em> para acceder a atributos de datos que funcionan como <em>&#8220;propiedades&#8221;</em> (<code>property</code>). Pero al iniciar esta serie de artículos dije que los <em>descriptores</em> son también <em>&#8220;los responsables del funcionamiento de  métodos, métodos estáticos, métodos de clase y del mecanismo <code>super()</code> responsable de la herencia múltiple&#8221;</em>.  Es el momento de ver cómo lo&nbsp;hacen:</p>
<h2>Métodos vistos como&nbsp;funciones</h2>
<p>Es común pensar que los métodos y las funciones comparten muchas similitudes. Considerando que en python las funciones son <a href="http://en.wikipedia.org/wiki/First-class_object">objetos de primera clase</a>  lo primero que podemos probar es a asignar directamente funciones a atributos de una clase para crear métodos <em>dinámicamente</em>:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">print</span> <span class="s2">&quot;obj is </span><span class="si">%s</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="n">obj</span>

<span class="n">C</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">func</span>

<span class="c1">#prueba del nuevo método</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>

<span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="p">()</span>    <span class="c1"># cualquiera de...</span>
<span class="n">C</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>   <span class="c1"># ...estas invocaciones...</span>
<span class="n">func</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>       <span class="c1"># ...dan el mismo resultado</span>
</pre></div>
</td></tr></table>

<p>Esta <em>dualidad</em> entre funciones y métodos va más allá si observamos que, en realidad, las funciones son <em>&#8220;descriptores&#8221;</em>, tal como podemos comprobar mirando su&nbsp;diccionario:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;__get__&quot;</span><span class="p">)</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="s2">&quot;__set__&quot;</span><span class="p">)</span>
<span class="bp">False</span>
</pre></div>
</td></tr></table>

<p>Concretamente, las funciones son <em>&#8220;descriptores de no-datos&#8221;</em> y como tales se aplicarán las reglas comentadas en artículos previos. En concreto, se buscarán antes los métodos en el diccionario del objeto que entre los atributos de su clase<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>, lo que nos va a permitir suplantar métodos en tiempo de&nbsp;ejecución.</p>
<p>Con añadir funciones a los atributos de clase será suficiente para la mayoría de casos que nos podamos enfrentar. El resto de este artículo va orientado para algunos casos de <em>&#8220;técnicas dinámicas&#8221;</em> que requieren diferenciar el comportamiento de un objeto respecto al resto de las instancias de la misma&nbsp;clase.</p>
<h2>Invocación de descriptores y sus&nbsp;enlaces</h2>
<p>Hasta ahora no nos habíamos preocupado por el segundo argumento que se pasa al método <code>__get__</code> en el interface &#8220;descriptor&#8221;, al que se denomina &#8220;propietario&#8221; (<em>&#8220;owner&#8221;</em>) y que siempre coincide con la clase de la instancia. A través de la instancia o del propietario, <code>__get__</code> devolverá el atributo enlazado con la instancia y/o clase según sea el comportamiento&nbsp;buscado.</p>
<p>Veamos cómo funciona en detalle: supongamos que tenemos una instancia <code>obj</code> de una clase <code>Cls</code> y accedemos a través del descriptor <code>desc</code>. Tendremos las siguientes formas de establecer el&nbsp;enlace:</p>
<ul>
<li>
<p><strong>Llamada directa</strong>: <code>__get__(obj)</code> invocación explícita a partir del descriptor. Es la más simple, aunque infrecuente. (pe: <code>desc.__get__(obj)</code>)</p>
</li>
<li>
<p><strong>Enlace con la Instancia</strong>: <code>__get__(obj, Cls)</code> Se usa en el acceso al atributo <code>obj.desc</code>, donde se efectúa la llamada implícita <code>Cls.__dict__['desc'].__get__(obj, Cls)</code></p>
</li>
<li>
<p><strong>Enlace con la clase</strong>: <code>__get__(None, Cls)</code> Se usa en el acceso al atributo <code>Cls.desc</code>, donde se efectúa la llamada implícita <code>Cls.__dict__['desc'].__get__(None, Cls)</code></p>
</li>
<li>
<p><strong>Enlace con <em>super</em></strong>:  se da con instancias de la clase <code>super</code> utilizadas en la herencia múltiple. El acceso al atributo <code>super(Cls, obj).desc</code> inicia una búsqueda en <code>obj.__class__.__mro__</code> para encontrar la clase base inmediatamente precedente a la clase <code>Cls</code> (=<code>SuperCls</code>) e invoca el descriptor con la llamada <code>SuperCls.__dict__['desc'].__get__(obj,  obj.__class__)</code> con lo que obtenemos el atributo enlazado con una de las clase  padre según el algoritmo <a href="http://cafepy.com/article/python_attributes_and_methods/ch02s04.html" title="Artículo recomendable sobre el algoritmo MRO"><span class="caps">MRO</span></a>.</p>
</li>
</ul>
<p>Como se puede observar, el método <code>__get__</code> del descriptor recibe diferentes argumentos según el enlace que se vaya a usar, lo que nos permitirá programar el descriptor según el uso que deseemos&nbsp;darle.</p>
<h2>Técnicas&nbsp;dinámicas</h2>
<p>Para realizar nuestros experimentos, supongamos que tenemos el siguiente&nbsp;descriptor:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">desc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>
</pre></div>
</td></tr></table>

<p>Es una simple función que imprime los argumentos que recibe con el fin de poder analizarlos. Con una clase y una instancia intentaremos ver cómo añadirles métodos&nbsp;dinámicos:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cls</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">obj</span><span class="o">=</span><span class="n">Cls</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>El caso trivial es añadir el descriptor como atributo de la&nbsp;clase:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">Cls</span><span class="o">.</span><span class="n">meth</span><span class="o">=</span><span class="n">desc</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">meth</span>
<span class="o">&lt;</span><span class="n">bound</span> <span class="n">method</span> <span class="n">Cls</span><span class="o">.</span><span class="n">desc</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Cls</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x8ffd3ac</span><span class="o">&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span>
<span class="p">(</span><span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Cls</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x8ffd3ac</span><span class="o">&gt;</span><span class="p">,)</span> <span class="p">{}</span>
</pre></div>
</td></tr></table>

<p>Encaja con el funcionamiento estándar de los descriptores, que pasa por establecer primero un enlace del descriptor con la instancia o con la clase para obtener después el método&nbsp;ejecutable.</p>
<p>Pero a veces necesitamos añadir métodos sobre la instancia y no sobre la clase. Ésto puede ser debido&nbsp;a:</p>
<ol>
<li>Sólo queremos modificar una instancia sin que afecte al&nbsp;resto</li>
<li>Queremos <em>&#8220;decorar&#8221;</em> el método de clase a través de un método de la&nbsp;instancia</li>
</ol>
<p>Técnicamente, son los llamados <strong>&#8220;métodos singleton&#8221;</strong> que lenguajes como <a href="http://www.ruby-doc.org/docs/ruby-doc-bundle/UsersGuide/rg/singletonmethods.html" title="Singleton methods in Ruby">ruby</a> incluyen en su sintaxis, pero que en python se implementan hackeando los&nbsp;descriptores.</p>
<p>Si añadiésemos un descriptor a una instancia sin establer ningún&nbsp;enlace:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">meth</span><span class="o">=</span><span class="n">desc</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span>
<span class="p">()</span> <span class="p">{}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">meth</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="n">desc</span> <span class="n">at</span> <span class="mh">0xb76776bc</span><span class="o">&gt;</span>
</pre></div>
</td></tr></table>

<p>Vemos que el funcionamiento es similar a si hubiéramos ejecutado directamente la función. En realidad, actúa como <strong>&#8220;métodos estáticos&#8221;</strong>, descriptores que no están enlazados con&nbsp;nada.</p>
<p>Para conseguir que el descriptor funcione como un método normal, necesitamos enlazarlo con la&nbsp;instancia:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">meth</span><span class="o">=</span><span class="n">desc</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Cls</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span>
<span class="p">(</span><span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Cls</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0xb767adec</span><span class="o">&gt;</span><span class="p">,)</span> <span class="p">{}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">meth</span>
<span class="o">&lt;</span><span class="n">bound</span> <span class="n">method</span> <span class="n">Cls</span><span class="o">.</span><span class="n">desc</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Cls</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0xb767adec</span><span class="o">&gt;&gt;</span>
</pre></div>
</td></tr></table>

<p>Aquí ya vemos que el método se identifica como un <strong>&#8220;método normal&#8221;</strong> más de la clase <code>Cls</code>.</p>
<p>De forma parecida, podríamos enlazar el descriptor con la clase, pero vista como instancia, no como clase, con lo que obtenemos un <strong>&#8220;método de clase&#8221;</strong>:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">meth</span><span class="o">=</span><span class="n">desc</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">Cls</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">Cls</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span>
<span class="p">(</span><span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">__main__</span><span class="o">.</span><span class="n">Cls</span><span class="s1">&#39;&gt;,) {}</span>
</pre></div>
</td></tr></table>

<p>Hemos visto las opciones posibles para realizar diversas técnicas dinámicas. No es habitual verlas en el código que usamos normalmente. Casi puedo asegurar que si necesitas alguna de estas técnicas, es que te has pasado por alto alguna otra forma más sencilla de hacer lo&nbsp;mismo.</p>
<h2>Pequeño&nbsp;truco</h2>
<p>Todo lo anteriormente dicho funciona siempre que estemos trabajando con <em>&#8220;descriptores de no-datos&#8221;</em>. Si deseamos que un método de la clase no sea suplantado por un método en la instancia basta con crearlo como <em>&#8220;descriptor de datos&#8221;</em>. Lo más sencillo es usar el decorador <code>@property</code>:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Cls</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="o">...</span>  <span class="nd">@property</span>
<span class="o">...</span>  <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="o">...</span>    <span class="k">print</span> <span class="s2">&quot;Desde clase&quot;</span>
<span class="o">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">=</span><span class="n">Cls</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">meth</span><span class="o">=</span><span class="n">desc</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="n">Cls</span><span class="p">)</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">AttributeError</span><span class="p">:</span> <span class="n">can</span><span class="s1">&#39;t set attribute</span>
</pre></div>
</td></tr></table>

<h2>Resto de artículos de la&nbsp;serie</h2>
<ol>
<li><a href="https://blog.ch3m4.org/2011/06/24/optimizaciones-con-los-metodos-especiales/">Optimizaciones con los Métodos&nbsp;Especiales</a></li>
<li><a href="https://blog.ch3m4.org/2011/06/26/metodo-__getattribute__/">Método&nbsp;__getattribute__</a></li>
<li><a href="https://blog.ch3m4.org/2011/06/19/descriptores-parte-1/">Descriptores – Parte&nbsp;1</a></li>
<li><a href="https://blog.ch3m4.org/2011/06/21/descriptores-parte-2/">Descriptores – Parte&nbsp;2</a></li>
</ol>
<h2>Descriptor&nbsp;Howto</h2>
<p>Como referencias en la documentación&nbsp;oficial:</p>
<ol>
<li><a href="http://docs.python.org/howto/descriptor.html">Descriptor HowTo&nbsp;Guide</a></li>
<li><a href="http://docs.python.org/release/3.1.5/reference/datamodel.html#implementing-descriptors">Implementing&nbsp;Descriptors</a></li>
</ol>
<div class="footnote">
<hr>
<ol>
<li id="fn:1">
<p>Este orden no se respeta con los <em>&#8220;métodos especiales&#8221;</em> y cuando estamos trabajando con <em>&#8220;descriptores de datos&#8221;</em>. Revisar el resto de artículos sobre descriptores.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
  </div>
  <hr>
  
  <ul class="pager">
          <li class="previous">
               <a href="https://blog.ch3m4.org/2012/05/12/lingua-franca/" title="Anterior">
                    <i class="fa fa-arrow-circle-left"></i>
                   Lingua&nbsp;Franca
               </a>
           </li>
           <li class="next">
              <a href="https://blog.ch3m4.org/2012/07/10/bom-marcas-de-orden-de-bytes/" title="Siguiente">
                   <span class="caps">BOM</span> - marcas de orden de&nbsp;bytes
                   <i class="fa fa-arrow-circle-right"></i>
               </a>
           </li>
   </ul>
   With category <a href="https://blog.ch3m4.org/category/python/">Python</a>:
   <ul class="pager">
          <li class="previous">
             <a href="https://blog.ch3m4.org/2012/04/04/problemas-con-los-nombres-largos-en-ntfs/" title="Anterior en misma categoría">
                <i class="fa fa-arrow-circle-o-left"></i>
                Problemas con los nombres largos en <span class="caps">NTFS</span>
             </a>
          </li>
        <li class="next">
             <a href="https://blog.ch3m4.org/2012/07/10/bom-marcas-de-orden-de-bytes/" title="Siguiente en misma categoría">
                 <span class="caps">BOM</span> - marcas de orden de&nbsp;bytes
                 <i class="fa fa-arrow-circle-o-right"></i>
             </a>
        </li>

   </ul>

    
  <div id="article_comments">
    <div id="disqus_thread">
    </div>
  </div>

  <script type="text/javascript">
    var disqus_identifier = "2012/06/05/descriptores-parte-3/";
    loadDisqus = function() {
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//hyperreals.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    };
    loadDisqus();
  </script>
</article>


    <div id="ending_message">
        <p>&copy; Chema Cortés. Built using <a href="http://getpelican.com">Pelican</a>. Theme is <a href="https://github.com/pR0Ps/pelican-subtle">subtle</a> by <a href="http://cmetcalfe.ca">Carey Metcalfe</a>. Based on <a href="https://github.com/giulivo/pelican-svbhack">svbhack</a> by Giulio Fidente.</p>
    </div>
  </main>

  <script type="text/javascript">
    window.addEventListener('load', function(){
    if (window.location.pathname != '/' && window.location.pathname != '/index.html'){
      window.scroll(0, document.getElementById('main').offsetTop);
    }})
  </script>


<script type="text/javascript">window.addEventListener("load", lw_timeago);</script>
</body>
</html>