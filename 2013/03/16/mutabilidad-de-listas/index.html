<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Chema Cortés">
  <meta name="description" content="Mutabilidad de Listas | Info Puedes visionar este artículo y descargártelo como notebook ipython en http://nbviewer.jupyter.org/5177340 Mucha gente,...">

  <link rel="stylesheet" type="text/css" href="https://chemacortes.github.io/blog/theme/css/styles.425931e9.min.css">

  <script src="https://chemacortes.github.io/blog/theme/js/scripts.7db5858b.min.js" type="text/javascript"></script>

  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">

  <link href="https://chemacortes.github.io/blog/blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Hyperreals *R Full Atom Feed" />

<meta name="keywords" content="functional programming, lambda calculus, math, programación, programming">

  <title>Mutabilidad de Listas | Hyperreals *R</title>

</head>

<body>
  <aside>
    <div id="user_meta">
      <a href="https://chemacortes.github.io/blog">
        <img src="https://s.gravatar.com/avatar/b20d114964d6d77c209aadbe9a152e87?s=80" id="logo">
      </a>
      <h2><a href="https://chemacortes.github.io/blog" class="nohover">Hyperreals *R</a></h2>
      <p>Quarks, bits y otras criaturas infinitesimales</p>
      <div class="social">
          <a href="https://twitter.com/chemacortes" title="twitter" target="_blank" rel="noopener noreferrer"><i class="fa fa-twitter fa-lg"></i></a>
          <a href="https://github.com/chemacortes" title="github" target="_blank" rel="noopener noreferrer"><i class="fa fa-github fa-lg"></i></a>
          <a href="https://bitbucket.org/chemacortes/" title="bitbucket" target="_blank" rel="noopener noreferrer"><i class="fa fa-bitbucket fa-lg"></i></a>
          <a href="https://stackoverflow.com/users/1243400/chemacortes" title="stackoverflow" target="_blank" rel="noopener noreferrer"><i class="fa fa-stack-overflow fa-lg"></i></a>
          <a href="https://linkedin.com/in/chemacortes" title="linkedin" target="_blank" rel="noopener noreferrer"><i class="fa fa-linkedin fa-lg"></i></a>
      </div>
      <ul>
        <li><a href="feeds/all.atom.xml" target="_blank" rel="noopener noreferrer">All Feeds<i class="fa fa-external-link-square fa-lg"></i></a></li>
        <li><a href="feeds/scala.atom.xml" target="_blank" rel="noopener noreferrer">Scala Feeds<i class="fa fa-external-link-square fa-lg"></i></a></li>
        <li><a href="feeds/python.atom.xml" target="_blank" rel="noopener noreferrer">Python Feeds<i class="fa fa-external-link-square fa-lg"></i></a></li>
        <li><a href="feeds/notas.atom.xml" target="_blank" rel="noopener noreferrer">Notas Feeds<i class="fa fa-external-link-square fa-lg"></i></a></li>
        <li><a href="https://mathstodon.xyz/@chemacortes" target="_blank" rel="noopener noreferrer">Mastodon<i class="fa fa-external-link-square fa-lg"></i></a></li>
      </ul>
    </div>
  </aside>

  <main id="main">
    <header>
      <p id="header">
      <a href="https://chemacortes.github.io/blog">Home</a>

      &#124; <a href="https://chemacortes.github.io/blog/pages/aboutme/">Quién&nbsp;soy</a>
      &#124; <a href="https://chemacortes.github.io/blog/pages/busqueda-python-es/">Búsqueda&nbsp;python-es</a>
      &#124; <a href="https://chemacortes.github.io/blog/blog/feeds/all.atom.xml">Atom Feed</a>
      </p>
<p>
<a href="https://chemacortes.github.io/blog/index.html">Posts</a>
&#124; <a href="https://chemacortes.github.io/blog/tag/">Tags</a>
&#124; <a href="https://chemacortes.github.io/blog/category/">Categories</a>
&#124; <a href="https://chemacortes.github.io/blog/archives.html">Archive</a>
</p>    </header>

<article>
<div class="article_meta">
  <p>Posted <time data-reltime datetime="2013-03-16T15:53:00+01:00">sáb 16 marzo 2013</time>
   by Chema Cortés  </p>
  <p>Last updated <time data-reltime datetime="2019-04-07T21:14:30+02:00">dom 07 abril 2019</time></p>
  <p>
  Category: <a href="https://chemacortes.github.io/blog/category/python/">Python</a>
</div>  <div class="article_title">
    <h1><a href="https://chemacortes.github.io/blog/2013/03/16/mutabilidad-de-listas/" class="nohover">Mutabilidad de&nbsp;Listas</a></h1>
  </div>
  <div class="article_text">
    <div class="admonition info">
<p class="admonition-title">Info</p>
<p>Puedes visionar este artículo y descargártelo como notebook ipython en <a href="http://nbviewer.jupyter.org/5177340">http://nbviewer.jupyter.org/5177340</a></p>
</div>
<p>Mucha gente, cuando se enfrenta por primera vez al lenguaje python, no entiende bien el concepto de <em>&#8220;inmutabilidad&#8221;</em> que tanto repite la documentación al tratar de diferenciar algunos tipos contenedores como tuplas, listas, conjuntos y&nbsp;diccionarios.</p>
<p>Por lo general, la gente formada en lenguajes de programación clásicos tiene la idea de que las variables son porciones de memoria donde colocar valores. Que una variable no se éso, <em>variable</em>, resulta un contrasentido. Han visto <em>constantes</em>, pero sólo sirven para inicializar variables y poco más. Si en su carrera hubieran sido formados en algún lenguaje funcional se darían cuenta que hay quienes piensan que las variables que cambian de valor son las raras, que lo más natural es que una variable conserve su valor inicial, o sea, que sea&nbsp;inmutable.</p>
<p>Por poner un ejemplo, el siguiente código está basado en una pregunta reciente en la lista <a href="http://docs.python.org/3.3/library/copy.html" title="Módulo copy">python-es</a>. Tenemos una lista de pares y queremos quitar las parejas repetidas con orden&nbsp;cambiado:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">quitar_dup</span><span class="p">(</span><span class="n">lista</span><span class="p">):</span>

    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">lista</span><span class="p">:</span>

        <span class="n">item</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">lista</span><span class="p">:</span>
            <span class="n">lista</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">lista</span>

<span class="n">L</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>

<span class="nb">print</span> <span class="n">quitar_dup</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>  <span class="c1">#res: [[1, 3], [3, 1]]</span>
</code></pre></div>

<p>A simple vista, el código parece correcto, pero tenemos dos operaciones que pueden mutar listas: <code>.reverse()</code> y <code>.remove()</code>. De hecho, el resultado es incorrecto: <code>[[1, 3], [3, 1]]</code></p>
<p>A medida que recorremos la lista en el bucle <code>for</code>, la lista se va modificando, lo que da lugar a resultados inesperados. Si no lo ves bien, basta añadir algunos <code>prints</code> en lugares estratégicos para que comprobar lo que pasa. De hecho, sólo existen dos iteraciones para cuatro elementos que tiene la&nbsp;lista.</p>
<p>Otro tipo de casos son cuando pasamos listas a&nbsp;funciones:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
<span class="o">...</span>   <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
<span class="o">...</span>     <span class="n">l</span> <span class="o">+=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="o">...</span>   <span class="k">return</span> <span class="n">l</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">L</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</code></pre></div>

<p>Como efecto colateral, la función ha modificado la lista pasada como argumento, algo que no es siempre deseable. El problema se agrava más si empleamos listas en valores por&nbsp;defecto:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="p">[]):</span>
<span class="o">...</span>   <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
<span class="o">...</span>     <span class="n">l</span> <span class="o">+=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="o">...</span>   <span class="k">return</span> <span class="n">l</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[])</span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</code></pre></div>

<p>Como se puede ver, aunque intentemos <em>resetear</em> el valor por defecto, la función tiene un efecto memoria que es imposible de eliminar. Este efecto es a veces buscado, pero en general debe ser siempre evitado ya que desvirtúa el sentido que tiene dar valores por&nbsp;defecto.</p>
<p>Estos efectos son todavía más perniciosos con la <em>funciones lambda</em>. Al carecer de una <em>clausura</em> como las funciones, la evaluación de una función lambda depende del <em>scope</em> donde han sido definidas. Por ejemplo, observa esta creación de una lista de&nbsp;funciones:</p>
<div class="highlight"><pre><span></span><code><span class="n">fns</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">fns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>

<span class="nb">print</span> <span class="n">fns</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="mi">10</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">fns</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span><span class="mi">10</span><span class="p">)</span>
</code></pre></div>

<p>Siempre añade <code>4</code> al argumento, que es el valor de <code>i</code> al acabar el bucle, independientemente de qué valor tenía esta variable en el momento de crear la función lambda. No es de extrañar que se recomiende dejar de usar estas&nbsp;funciones.</p>
<p>Por último, otro efecto funesto de la mutabilidad de las listas aparece en la creación de <em>listas multidimensionales</em> (aka <em>matrices</em>). Una forma rápida de crear una matriz de 2x2 es: <code>[[0]*2]*2</code>. El problema aquí está en que cuando clonamos listas, en lugar de copiar los elementos, los enlaza entre sí. Quizás se vea mejor si hacemos alguna&nbsp;operación:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; l = [[0]*2]*2
[[0, 0], [0, 0]]
&gt;&gt;&gt; l[0][0]
0
&gt;&gt;&gt; l[0][0] = 1
&gt;&gt;&gt; l
[[1, 0], [1, 0]]
&gt;&gt;&gt; l[0] is l[1]
True
</code></pre></div>

<p>Los elementos <code>l[0]</code> y <code>l[1]</code> son el mismo elemento. Que los elementos de una lista puedan estar <em>entrelazados</em> resulta muy interante para algunos algoritmos de búsquedas. Pero hay que conocer bien lo que estamos haciendo si no queremos llevarnos alguna&nbsp;sorpresa.</p>
<h2>Recomendaciones para hacer código&nbsp;funcional</h2>
<h3>Copia de&nbsp;listas</h3>
<p>En funciones y métodos, si recibimos una lista como argumento, la primera acción defensiva que deberíamos hacer es copiar la lista en una variable local y trabajar solo con la variable local desde ese momento. Con una asignación directa no se realiza una copia, más bien estaríamos <em>enlazando</em> una nueva referenciasin solucionar&nbsp;nada.</p>
<p>La forma consensuada entre programadores python de copiar una lista es con la operación de <em>spliting</em> <code>L[:]</code>, aunque sirven otras operaciones idempotentes como <code>L*1</code> ó <code>L+[]</code><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup>. Para listas de elementos entrelazados tendremos que acudir a otros mecanismos de copia como los que ofrece el <a href="http://docs.python.org/3.3/library/copy.html" title="Módulo copy">módulo <code>copy</code></a>, aunque no será frecuente que lo&nbsp;necesitemos.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">lista</span><span class="p">):</span>
  <span class="n">l</span> <span class="o">=</span> <span class="n">lista</span><span class="p">[:]</span>
  <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
    <span class="n">l</span> <span class="o">+=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">l</span>
</code></pre></div>

<p>En cuanto a los argumentos por defecto, lo mejor es no usar nunca una lista para tal cosa. Una buena estrategia defensiva consiste en usar <code>None</code> de esta&nbsp;forma:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">lista</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">lista</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">lista</span><span class="p">[:]</span>
  <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
    <span class="n">l</span> <span class="o">+=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">l</span>
</code></pre></div>

<h3>Operaciones inmutables con&nbsp;listas</h3>
<p>En cuanto a evitar las operaciones que mutan listas, siempre hay alternativas inmutables de todas estas operaciones. El siguiente cuadro puede servir como&nbsp;referencia:</p>
<table>
<thead>
<tr>
<th>Mutable</th>
<th>Inmutable</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>L.append(item)</code></td>
<td><code>L+[item]</code></td>
</tr>
<tr>
<td><code>L.extend(sequence)</code></td>
<td><code>L + list(sequence)</code></td>
</tr>
<tr>
<td><code>L.insert(index, item)</code></td>
<td><code>L[:index] + [item] + L[index:]</code></td>
</tr>
<tr>
<td><code>L.reverse()</code></td>
<td><code>L[::-1]</code></td>
</tr>
<tr>
<td><code>L.sort()</code></td>
<td><code>sorted(L)</code></td>
</tr>
<tr>
<td><code>item = L.pop()</code></td>
<td><code>item,L = L[-1],L[:-1]</code></td>
</tr>
<tr>
<td><code>item = L.pop(0)</code></td>
<td><code>item,L = L[0],L[1:]</code></td>
</tr>
<tr>
<td><code>item = L.pop(index)</code></td>
<td><code>item, L = L[item], L[:item]+L[item+1:]</code></td>
</tr>
<tr>
<td><code>L.remove(item)</code></td>
<td><code>L=L[:item]+L[item+1:]</code></td>
</tr>
<tr>
<td><code>L[i:j] = K</code></td>
<td><code>L[:i] + K + L[j:]</code></td>
</tr>
</tbody>
</table>
<p>A la hora de decidir qué versión usar, la versión inmutable es más apropiada para programación funcional y resulta incluos más intuitiva de interpretar. No es extraño ver errores de código donde se espera resultados de las operaciones <code>.sort()</code> o <code>.reverse()</code>, que siempre devuelven <code>None</code>. Para el intérprete de python no hay error, pero a veces nos será difícil darnos cuenta de estos&nbsp;errores:</p>
<p><em><span class="caps">MODO</span> ERRÓNEO: machacamos la lista con&nbsp;None</em></p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l_2</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">sort</span><span class="p">()]</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">TypeError</span><span class="p">:</span> <span class="s1">&#39;NoneType&#39;</span> <span class="nb">object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">iterable</span>
</code></pre></div>

<p><em><span class="caps">MODO</span> <span class="caps">CORRECTO</span></em></p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l_2</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l_2</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">]</span>
</code></pre></div>

<div class="footnote">
<hr>
<ol>
<li id="fn:1">
<p>De hecho, la operación <code>L*1</code> es más eficiente que <code>L[:]</code>.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
  </div>

  <div id="article_comments">
    <div id="disqus_thread">
    </div>
  </div>

  <script id="dsq-count-scr" src="https://hyperreals.disqus.com/count.js" async></script>
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.identifier = "2013/03/16/mutabilidad-de-listas/";
        this.page.title = "Mutabilidad de&nbsp;Listas";
    };
    loadDisqus = function(sitename) {
      var d = document, s = d.createElement('script');
      s.src = 'https://hyperreals.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    };
    loadDisqus();
  </script>
</article>


    <div id="ending_message">
        <p>&copy; Chema Cortés. Built using <a href="http://getpelican.com">Pelican</a>. Theme is <a href="https://github.com/pR0Ps/pelican-subtle">subtle</a> by <a href="http://cmetcalfe.ca">Carey Metcalfe</a>. Based on <a href="https://github.com/giulivo/pelican-svbhack">svbhack</a> by Giulio Fidente.</p>
    </div>
  </main>

  <script type="text/javascript">
    window.addEventListener('load', skipHeader)
  </script>


</body>
</html>