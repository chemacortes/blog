<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Hyperreals *R - Scala</title><link href="https://blog.ch3m4.org/" rel="alternate"></link><link href="https://blog.ch3m4.org/feeds/scala.atom.xml" rel="self"></link><id>https://blog.ch3m4.org/</id><updated>2021-10-28T19:55:46+02:00</updated><subtitle>Quarks, bits y otras criaturas infinitesimales</subtitle><entry><title>Build Server Protocol</title><link href="https://blog.ch3m4.org/2021/10/24/bsp/" rel="alternate"></link><published>2021-10-24T18:06:48+02:00</published><updated>2021-10-28T19:55:46+02:00</updated><author><name>Chema Cortés</name></author><id>tag:blog.ch3m4.org,2021-10-24:/2021/10/24/bsp/</id><summary type="html">&lt;p&gt;Mediante el protocolo &lt;span class="caps"&gt;BSP&lt;/span&gt;, la intereacción de un editor o &lt;span class="caps"&gt;IDE&lt;/span&gt; con las herramientas de desarrollo se ha llevado a una arquitectura cliente-servidor que mejora la experiencia de usuario con sus herramientas de desarrollo habituales, sin renunciar a la comodidad de usar una entorno&amp;nbsp;gráfico.&lt;/p&gt;</summary><content type="html">&lt;p&gt;La elección de un editor, un &lt;span class="caps"&gt;IDE&lt;/span&gt; o cualquier otra herramienta de desarrollo se
acaba convirtiendo en una decisión personal del programador. Todos tenemos
nuestras herramientas favoritas que variamos según sea la naturaleza del
proyecto o el lenguaje de programación que&amp;nbsp;usemos.&lt;/p&gt;
&lt;p&gt;Las herramientas de desarrollo más importantes son las que controlan el ciclo de
&lt;strong&gt;compilación, test y ejecución&lt;/strong&gt;, como pueden ser &lt;code&gt;maven&lt;/code&gt;, &lt;code&gt;gradle&lt;/code&gt;, &lt;code&gt;sbt&lt;/code&gt; o
&lt;code&gt;mill&lt;/code&gt;, por sólo citar algunas de las usadas normalmente en scala. Estas
herramientas condicionan cómo se estructura nuestro proyecto y cómo realizar las
tareas más habituales durante el&amp;nbsp;desarrollo.&lt;/p&gt;
&lt;p&gt;Cada &lt;span class="caps"&gt;IDE&lt;/span&gt; se las ingenia para extraer de un proyecto toda la información
necesaria para la compilación, detectando los directorios con código que
presenta como &lt;em&gt;espacio de trabajo&lt;/em&gt; (&lt;em&gt;workspace&lt;/em&gt;) donde el programador pueda
trabajar, ver, escribir y compilar el código. Si puede, extrae esta información
de las herramientas de desarrollo, aunque no siempre es&amp;nbsp;posible.&lt;/p&gt;
&lt;p&gt;Muchas veces, el soporte que da un &lt;span class="caps"&gt;IDE&lt;/span&gt; a un determinado lenguaje, a una librería
o a una plataforma no es todo lo completo posible. Muchas veces el soporte era
parcial, sólo el coloreado de sintáxis y poco más. En otras, la detección de
errores se quedaba corta y había que acudir a una compilación manual para
detectar los errores más arcanos. Era casi imposible tener un &lt;span class="caps"&gt;IDE&lt;/span&gt; completo que
se pudiera usar con cualquier lenguaje y librería, por lo que era obligando el
cambio entre editores, IDEs y herramientas buscando el mejor&amp;nbsp;soporte.&lt;/p&gt;
&lt;h2&gt;&lt;span class="caps"&gt;LSP&lt;/span&gt; - Language Server&amp;nbsp;Protocol&lt;/h2&gt;
&lt;p&gt;Para racionalizar esta situación, Microsoft sacó el &lt;a href="https://microsoft.github.io/language-server-protocol/" title="Language Server Protocol"&gt;Language Server Protocol
(&lt;span class="caps"&gt;LSP&lt;/span&gt;)&lt;/a&gt;. Basado en una arquitectura cliente-servidor, los editores e IDEs
pasan a ser &lt;em&gt;clientes&lt;/em&gt; de servidores &lt;span class="caps"&gt;LSP&lt;/span&gt;, uno para cada lenguaje, comunicándose
con ellos a través de un protocolo común. Gracias a los servidores &lt;span class="caps"&gt;LSP&lt;/span&gt; se hacen
tareas tan comunes como el resaltado de sintáxis, autocompletado, localización
de errores de sintáxis, formateo de código, búsqueda de referencias, etc.
Además, los propios creadores de los lenguajes vigilan la calidad de estos
servidores, lo que aporta mayor&amp;nbsp;fiabilidad.&lt;/p&gt;
&lt;p&gt;Existen &lt;a href="https://microsoft.github.io/language-server-protocol/implementors/servers/" title="Implementaciones LSP"&gt;implementaciones&lt;/a&gt; para muchos lenguajes. IDEs como Visual Code
instalan estos servidores &lt;span class="caps"&gt;LSP&lt;/span&gt; junto al instalar la extensión del lenguaje que
vayamos a usar, por lo que no requiere instalarlos manualmente. Lo importante es
saber que podemos usar el mismo servidor en cualquier editor e &lt;span class="caps"&gt;IDE&lt;/span&gt; que soporte
el protocolo &lt;span class="caps"&gt;LSP&lt;/span&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;span class="caps"&gt;BSP&lt;/span&gt; - Build Server&amp;nbsp;Protocol&lt;/h2&gt;
&lt;p&gt;Desarrollando la idea de &lt;span class="caps"&gt;LSP&lt;/span&gt;, surge el &lt;a href="https://build-server-protocol.github.io" title="Build Server Protocol"&gt;Build Server Protocol (&lt;span class="caps"&gt;BSP&lt;/span&gt;)&lt;/a&gt; como
colaboración entre el &lt;strong&gt;Scala Center&lt;/strong&gt; y &lt;strong&gt;JetBrain&lt;/strong&gt;. La interacción entre el
&lt;span class="caps"&gt;IDE&lt;/span&gt; y las herramientas de desarrollo se llevan a una arquitectura
cliente-servidor. El servidor &lt;span class="caps"&gt;BSP&lt;/span&gt; siempre está corriendo de fondo y será quien
se encargue de informar al &lt;span class="caps"&gt;IDE&lt;/span&gt; sobre la estructura del proyecto, dónde están los
errores de compilación o enlazado, del resultado de los test,&amp;nbsp;etc.&lt;/p&gt;
&lt;p&gt;&lt;img src="/pictures/bsp.png" width="400" title="Interacción cliente-servidor BSP" alt="Build Server Protocol"&gt;&lt;/p&gt;
&lt;h2&gt;Metals&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Metals&lt;/strong&gt; es un servidor &lt;span class="caps"&gt;LSP&lt;/span&gt; para &lt;em&gt;scala&lt;/em&gt; y es, además, un cliente &lt;span class="caps"&gt;BSP&lt;/span&gt;.
Controla todo el ciclo de desarrollo, desde la creación de un proyecto usando
una plantilla, su compilación, prueba y ejecución, y su&amp;nbsp;depurado.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;metals&lt;/em&gt; puede usar como servidores &lt;span class="caps"&gt;BSP&lt;/span&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://scalacenter.github.io/bloop/"&gt;&lt;strong&gt;bloop&lt;/strong&gt;&lt;/a&gt;, el servidor &lt;span class="caps"&gt;BSP&lt;/span&gt; por defecto en &lt;em&gt;metals&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sbt server (&lt;em&gt;sbtn&lt;/em&gt;)&lt;/strong&gt;, incluído con la herramienta &lt;code&gt;sbt&lt;/code&gt; (aunque tiene
  algunos fallos aún en su última versión &lt;code&gt;1.5,5&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Si usas &lt;code&gt;sbt&lt;/code&gt; regularmente, igual te conviene usar su servidor para evitar
incoherencias en la compilación. Pero &lt;code&gt;bloop&lt;/code&gt; es algo más rápido, más fiable y
se puede usar también con más herramientas como &lt;em&gt;maven&lt;/em&gt;, &lt;em&gt;gradle&lt;/em&gt; y &lt;em&gt;mill&lt;/em&gt;. Mi
recomendación es dejar que &lt;em&gt;metals&lt;/em&gt; te recomiende qué&amp;nbsp;usar.&lt;/p&gt;
&lt;h2&gt;&lt;span class="caps"&gt;DAP&lt;/span&gt; - Debug Adaptar&amp;nbsp;Protocol&lt;/h2&gt;
&lt;p&gt;Todavía hay algo más. Se está trabajando en un protocolo denominado &lt;a href="https://microsoft.github.io/debug-adapter-protocol/" title="Debug Adapter Protocol"&gt;Debug
Adaptar Protocol (&lt;span class="caps"&gt;DAP&lt;/span&gt;)&lt;/a&gt; que estandariza las tareas de ejecución, testing y
depurado. Basta añadir un &lt;em&gt;adaptador &lt;span class="caps"&gt;DAP&lt;/span&gt;&lt;/em&gt; para que podamos usar nuestro &lt;span class="caps"&gt;IDE&lt;/span&gt; en
tareas de depurado para ese&amp;nbsp;lenguaje.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;bloop&lt;/em&gt; implementa por defecto el protocolo &lt;span class="caps"&gt;DAP&lt;/span&gt;. Esta implementación ha sido
sacada como &lt;em&gt;plugin&lt;/em&gt; de sbt, &lt;a href="https://github.com/scalacenter/scala-debug-adapter"&gt;sbt-debug-adapter&lt;/a&gt;, que ahora se puede usar con
otras herramientas scala. En concreto, se puede usar con el &lt;em&gt;servidor sbt&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Usando &lt;em&gt;metals&lt;/em&gt;, la configuración para &lt;span class="caps"&gt;DAP&lt;/span&gt; es automática, uses &lt;em&gt;bloop&lt;/em&gt; o &lt;em&gt;sbtn&lt;/em&gt;,
por lo que no tienes que preocuparte de configurar&amp;nbsp;nada.&lt;/p&gt;</content><category term="Scala"></category><category term="devtools"></category></entry><entry><title>Factorial en scala en paralelo</title><link href="https://blog.ch3m4.org/2018/07/25/factorial-en-scala-en-paralelo/" rel="alternate"></link><published>2018-07-25T20:49:57+02:00</published><updated>2018-08-14T01:00:09+02:00</updated><author><name>Chema Cortés</name></author><id>tag:blog.ch3m4.org,2018-07-25:/2018/07/25/factorial-en-scala-en-paralelo/</id><summary type="html">&lt;p&gt;Una nueva versión del factorial en scala, ahora en&amp;nbsp;paralelo&lt;/p&gt;</summary><content type="html">&lt;p&gt;Una obsesión de este blog siempre ha sido crear cálculos de la función &lt;em&gt;factorial&lt;/em&gt; con diversos algoritmos y con cualquier&amp;nbsp;lenguaje.&lt;/p&gt;
&lt;p&gt;Para no perder la costumbre, veamos una de las formas más rápidas de calcular un factorial aprovechando las CPUs multicores que equipan los equipos&amp;nbsp;modernos.&lt;/p&gt;
&lt;p&gt;Teníamos en scala una definición de este&amp;nbsp;estilo:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="nc"&gt;BigInt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;BigInt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;product&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;El producto de los números se realiza en secuencia, desde el &lt;code&gt;2&lt;/code&gt; hasta &lt;code&gt;n&lt;/code&gt;. Como variante podíamos haber recorrido la secuencia en orden&amp;nbsp;inverso:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nc"&gt;BigInt&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="nc"&gt;BigInt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;product&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Puede pensarse que el orden en el que se multiplican los números podría influir en el tiempo de cómputo, pero las pruebas que he hecho no parece que tenga demasiada influencia. Tal vez resulte ligeramente más costosa en orden&amp;nbsp;inverso.&lt;/p&gt;
&lt;p&gt;Una forma simple que tenemos de acelerar el producto sería convertir la secuencia en una &lt;em&gt;colección paralela&lt;/em&gt;, algo tan sencillo como invocar el método &lt;code&gt;.par&lt;/code&gt; de la&amp;nbsp;secuencia:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="nc"&gt;BigInt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;BigInt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;par&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;product&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Ahora el producto se realiza en paralelo, usando todos los &lt;em&gt;cores&lt;/em&gt; disponibles de la &lt;span class="caps"&gt;CPU&lt;/span&gt;. Para números pequeños, casi no se nota el incremento de velocidad debido a los cambios de contexto que realiza el cómputo. Pero en números bastantes grandes, la velocidad se multiplica prácticamente por el número de cores&amp;nbsp;disponibles.&lt;/p&gt;</content><category term="Scala"></category><category term="algorithms"></category><category term="factorial"></category></entry><entry><title>Estudio función factorial en scala - operador sufix</title><link href="https://blog.ch3m4.org/2012/08/15/estudio-funcion-factorial-en-scala-operador-sufix/" rel="alternate"></link><published>2012-08-15T09:30:00+02:00</published><updated>2012-08-15T09:30:00+02:00</updated><author><name>Chema Cortés</name></author><id>tag:blog.ch3m4.org,2012-08-15:/2012/08/15/estudio-funcion-factorial-en-scala-operador-sufix/</id><summary type="html">&lt;p&gt;A medida que voy aprendiendo más sobre el lenguaje &lt;strong&gt;scala&lt;/strong&gt;, se me ocurren nuevas formas de expresar la función&amp;nbsp;factorial.&lt;/p&gt;
&lt;p&gt;La &lt;em&gt;&amp;#8220;expresividad&amp;#8221;&lt;/em&gt; del lenguaje permite usar operadores para crear código más corto. Por ejemplo, la función factorial con &lt;em&gt;&amp;#8220;plegados&amp;#8221;&lt;/em&gt; (&lt;em&gt;&amp;#8220;folds&lt;/em&gt;&amp;#8220;) que poníamo en un artículo anterior se podría expresar&amp;nbsp;así …&lt;/p&gt;</summary><content type="html">&lt;p&gt;A medida que voy aprendiendo más sobre el lenguaje &lt;strong&gt;scala&lt;/strong&gt;, se me ocurren nuevas formas de expresar la función&amp;nbsp;factorial.&lt;/p&gt;
&lt;p&gt;La &lt;em&gt;&amp;#8220;expresividad&amp;#8221;&lt;/em&gt; del lenguaje permite usar operadores para crear código más corto. Por ejemplo, la función factorial con &lt;em&gt;&amp;#8220;plegados&amp;#8221;&lt;/em&gt; (&lt;em&gt;&amp;#8220;folds&lt;/em&gt;&amp;#8220;) que poníamo en un artículo anterior se podría expresar&amp;nbsp;así:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;BigInt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))(&lt;/span&gt;&lt;span class="n"&gt;_*_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;En esta expresión, hacemos el &lt;em&gt;plegado&lt;/em&gt; de la secuencia &lt;code&gt;(1 to n)&lt;/code&gt; sobre el valor inicial &lt;code&gt;BigInt(1)&lt;/code&gt; con la operación &lt;code&gt;(_*_)&lt;/code&gt; (multiplicación). Se ve rara, pero una vez profundizas en scala se ve como algo&amp;nbsp;normal.&lt;/p&gt;
&lt;p&gt;Otra de las opciones de scala es poder usar casi cualquier carácter como indentificador, lo que nos facilita la creación de &lt;span class="caps"&gt;DSL&lt;/span&gt; (&lt;em&gt;&amp;#8220;Lenguajes Específicos al Dominio&amp;#8221;&lt;/em&gt;). Una de estas posibilidades sería crear el operador &lt;em&gt;sufix&lt;/em&gt; de la función factorial, de modo que el cálculo de factorial de &lt;code&gt;n&lt;/code&gt; se pudiera expresar como &lt;code&gt;n!&lt;/code&gt;. Para ello aprovechamos el mecanismo que tiene scala para conversión automática de tipos de&amp;nbsp;datos:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Factorizer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;!&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;BigInt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;product&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;implicit&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;int2fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Factorizer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;5!=&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;La explicación es bien sencilla: como no encuentra el método &lt;code&gt;'!'&lt;/code&gt; en el tipo &lt;code&gt;Int&lt;/code&gt;, busca entre las conversiones otros tipos que lo puedan tener, en este caso &lt;code&gt;Factorizer&lt;/code&gt;. Una vez hecha la conversión, ejecuta el&amp;nbsp;operador.&lt;/p&gt;</content><category term="Scala"></category><category term="algorithm"></category><category term="factorial"></category></entry><entry><title>Estudio función factorial en scala - Revisión funcional</title><link href="https://blog.ch3m4.org/2012/02/07/estudio-funcion-factorial-en-scala-revision-funcional/" rel="alternate"></link><published>2012-02-07T13:41:00+01:00</published><updated>2012-02-07T13:41:00+01:00</updated><author><name>Chema Cortés</name></author><id>tag:blog.ch3m4.org,2012-02-07:/2012/02/07/estudio-funcion-factorial-en-scala-revision-funcional/</id><summary type="html">&lt;p&gt;Como programador de python que todavía anda algo despistado estudiando scala, ahora empiezo a captar la filosófía que hay detrás de este lenguaje de programación. Mientras que python empienza a erradicar poco a poco la programación funcional, en scala su influencia es cada vez mayor hasta el extremo de considerar …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Como programador de python que todavía anda algo despistado estudiando scala, ahora empiezo a captar la filosófía que hay detrás de este lenguaje de programación. Mientras que python empienza a erradicar poco a poco la programación funcional, en scala su influencia es cada vez mayor hasta el extremo de considerar precindibles la mayoría de los bucles. Aún asi, ambos lenguajes soportan la &lt;em&gt;&amp;#8220;compresión de listas&amp;#8221;&lt;/em&gt; como técnica a medio camino entre funcional y bucle estándar, aunque esta técnica está más orientada a obtener listas a partir de otras listas, y no para realizar cálculos sobre un conjunto de&amp;nbsp;números.&lt;/p&gt;
&lt;p&gt;Voy a completar el anterior artículo que trataba del &lt;a href="https://blog.ch3m4.org/2011/10/17/estudio-funcion-factorial-en-scala/"&gt;&amp;#8220;Estudio función factorial en scala&amp;#8221;&lt;/a&gt; con algunas formas más &lt;em&gt;&amp;#8220;funcionales&amp;#8221;&lt;/em&gt; de definir el&amp;nbsp;factorial:&lt;/p&gt;
&lt;p&gt;La forma más simple de definir la función&amp;nbsp;factorial:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;product&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;En realidad, &lt;code&gt;1 to n&lt;/code&gt; no es un elemento sintáctico del lenguaje, si no más bien la forma &lt;em&gt;alternativa&lt;/em&gt; de escribir la invocación del método &lt;code&gt;1.to(n)&lt;/code&gt;. Este método nos genera una secuencia de números desde el 1 al n (equivalente en python a&amp;nbsp;range(1,n+1)).&lt;/p&gt;
&lt;p&gt;Curiosamente, también está definido &lt;code&gt;fact(0)&lt;/code&gt; gracias a que &lt;code&gt;product&lt;/code&gt; da como resultado el elemento neutro &lt;code&gt;1&lt;/code&gt; en secuencias vacías &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;Esta forma concisa de calcular el producto es común a todas las secuencias en scala. Faltaría, tan sólo, que operara con BigInts para que fuera&amp;nbsp;perfecta:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;BigInt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;product&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;No es necesario indicar el tipo devuelto por la función puesto que el compilador es capaz de inferirlo de la&amp;nbsp;expresión.&lt;/p&gt;
&lt;p&gt;Otra forma funcional sería usando el método &lt;code&gt;reduce&lt;/code&gt;, donde se indica &lt;em&gt;explícitamente&lt;/em&gt; la operación binaria a realizar entre pares de&amp;nbsp;elementos:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;BigInt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_*_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Como operación se pone una especie de &lt;em&gt;plantilla&lt;/em&gt; (&lt;em&gt;pattern&lt;/em&gt;) que representa la operación binaria de multiplicación. Por comparar, en python se puede hacer algo&amp;nbsp;así:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;operator&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="fm"&gt;__mul__&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
   &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="fm"&gt;__mul__&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Lamentablemente, el operador funcional &lt;code&gt;'reduce'&lt;/code&gt; está desapareciendo de python por considerarlo complejo de entender en su funcionamiento &lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;Por último, aún existe otra forma funcional de expresar el factorial en scala. Son los &lt;em&gt;&amp;#8220;plegados&amp;#8221;&lt;/em&gt; (&lt;em&gt;folds&lt;/em&gt;), similar en funcionamiento a &lt;code&gt;reduce&lt;/code&gt;, pero con control sobre la dirección del recorrido y la posibilidad de dar un valor&amp;nbsp;inicial:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;foldLeft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;BigInt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))(&lt;/span&gt;&lt;span class="n"&gt;_*_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Seguro que pronto se me ocurrirán más&amp;nbsp;formas.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;En el caso del método &lt;code&gt;sum&lt;/code&gt; daría el elemento neutro para la suma, o sea, el &lt;code&gt;0&lt;/code&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Personalmente, considero que la desaparición de la programación funcional se debe más a la corta visión de quién sólo ve un encadenamiento de sentencias, en lugar de ver &lt;em&gt;&amp;#8220;actores&amp;#8221;&lt;/em&gt; interaccionando en libre concurrencia.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Scala"></category><category term="algorithm"></category><category term="factorial"></category></entry><entry><title>Estudio función factorial en scala</title><link href="https://blog.ch3m4.org/2011/10/17/estudio-funcion-factorial-en-scala/" rel="alternate"></link><published>2011-10-17T20:49:00+02:00</published><updated>2011-10-17T20:49:00+02:00</updated><author><name>Chema Cortés</name></author><id>tag:blog.ch3m4.org,2011-10-17:/2011/10/17/estudio-funcion-factorial-en-scala/</id><summary type="html">&lt;p&gt;Como continuación al artículo que dediqué al &lt;a href="https://blog.ch3m4.org/2011/06/06/estudio-funcion-factorial/"&gt;estudio del factorial&lt;/a&gt;, voy a explicar cómo se haría este famoso algoritmo usando &lt;a href="http://scala-lang.org" title="Scala programming language"&gt;scala&lt;/a&gt;. Tengo que añadir que tan sólo llevo una semana con el lenguaje scala, por lo que es muy probable que haya algún aspecto de este lenguaje que me haya …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Como continuación al artículo que dediqué al &lt;a href="https://blog.ch3m4.org/2011/06/06/estudio-funcion-factorial/"&gt;estudio del factorial&lt;/a&gt;, voy a explicar cómo se haría este famoso algoritmo usando &lt;a href="http://scala-lang.org" title="Scala programming language"&gt;scala&lt;/a&gt;. Tengo que añadir que tan sólo llevo una semana con el lenguaje scala, por lo que es muy probable que haya algún aspecto de este lenguaje que me haya dejado por el&amp;nbsp;camino.&lt;/p&gt;
&lt;h2&gt;Versión recursiva (y &lt;em&gt;one-line&lt;/em&gt;)&lt;/h2&gt;
&lt;p&gt;La forma básica de la función&amp;nbsp;sería:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="nc"&gt;BigInt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Si se compara con la función recursiva en python, no parece que haya mucha diferencia, con excepción de que en scala existe el tipado de&amp;nbsp;datos.&lt;/p&gt;
&lt;p&gt;Esta función es en realidad una sóla línea, por lo que podíamos haberla escrito de esta&amp;nbsp;manera:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="nc"&gt;BigInt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Es una clara señal de la orientación funcional que tiene&amp;nbsp;scala.&lt;/p&gt;
&lt;p&gt;Al igual que python, esta función recursiva se corta cuando se sobrepasa un cierto límite de llamadas recursivas para proteger la memoria del&amp;nbsp;sistema.&lt;/p&gt;
&lt;p&gt;El compilador de Scala posee una optimización especial denominda de &lt;em&gt;&amp;#8220;LLamada Terminal&amp;#8221;&lt;/em&gt; (&lt;a href="http://en.wikipedia.org/wiki/Tail_call" title="Tail Call"&gt;Tail Call&lt;/a&gt;)&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt; (optimización que no existe en &lt;span class="caps"&gt;JVM&lt;/span&gt;). Este tipo de optimizaciones son posibles cuando la última línea a ejecutar de la función es únicamente la llamada recursiva a sí misma, con lo cuál hace innecesario guardar el stack de ejecución puesto que no quedarían más líneas para&amp;nbsp;ejecutar.&lt;/p&gt;
&lt;p&gt;Para que sea posible aplicar esta optimización de &amp;#8220;llamada terminal&amp;#8221;, tenemos que reescribir nuestra función de modo que la última línea sea una llamada a sí misma. Para ello usaremos una función acumuladora que se encargue de realizar la multiplicación previamente a la llamada. Casi mejor si vemos el&amp;nbsp;código:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="nc"&gt;BigInt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;factAcc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nc"&gt;BigInt&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="nc"&gt;BigInt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;factAcc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;factAcc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;En las últimas versiones de scala existe una &lt;em&gt;&amp;#8220;anotación&amp;#8221;&lt;/em&gt; especial para indicar al compilador de scala que intente aplicar la optimización de &amp;#8220;LLamada Terminal&amp;#8221;, o que nos dé un aviso de no poder hacerlo. Finalmente, así quedaría el código de nuestra función&amp;nbsp;recursiva:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;scala&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nn"&gt;annotation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tailrec&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="nc"&gt;BigInt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;@tailrec&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;factAcc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nc"&gt;BigInt&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="nc"&gt;BigInt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;factAcc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;factAcc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Versión&amp;nbsp;iterativa&lt;/h2&gt;
&lt;p&gt;Es la versión más&amp;nbsp;sencilla:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="nc"&gt;BigInt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;BigInt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;*=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;
    &lt;span class="n"&gt;res&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Fórmula de&amp;nbsp;Stirling&lt;/h2&gt;
&lt;p&gt;Para completar el estudio, podemos ver cómo sería la función de Stiling en Scala, bastante similar, como puede verse, a su versión en&amp;nbsp;python:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="nc"&gt;Double&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
    &lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nc"&gt;Pi&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nc"&gt;E&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Existe algún intento para implementar esta optimización de &amp;#8220;Tail Call&amp;#8221; en python, con algunos decoradores más o menos funcionales. Si quieres ver motivos en contra, visita el artículo que escribió Guido sobre el tema: &lt;a href="http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html"&gt;http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Scala"></category><category term="algorithm"></category><category term="factorial"></category></entry></feed>